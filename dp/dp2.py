# coding: utf-8
""" 过桥问题
DP 的线性模型

在一个夜黑风高的晚上，有n（n <= 50）个小朋友在桥的这边，现在他们需要过桥，但是由于桥很窄，每次只允许不大于两人通过，
他们只有一个手电筒，所以每次过桥的两个人需要把手电筒带回来，i号小朋友过桥的时间为T[i]，
两个人过桥的总时间为二者中时间长者。问所有小朋友过桥的总时间最短是多少。
"""


class Solution():
    def over_bridge(self, p, n):
        # 可以得到关系：当 n 大于 2 时，会有总次数 N=2*n-3
        # （理由中间每个人都需要接送共两次，除了开头2人队中的一人以及结束的2人队不需要返回外）
        # 解决思路：状态转移方程
        # 1. 先将每个人按花费时间从小到大排序
        # 2. 考虑来岸只剩一个人，对岸有 n-1 个人，则可以知道应该派最快的人来回接送为最短，即 MIN(N) = MIN(N-1) + 2*p[1] + p[n]
        # 3. 考虑来岸有两个人，则对岸有 n-2 个人（其中一个为 n，另一个为 1），
        #    让最快的人（2）把手电筒送过来，带n走，最后2回来和1一起走
        #    即 MIN(N) = MIN(N-2) + 2*p[2] + p[n] + p[1]
        # 4. 得到完整的方程式 MIN(N) = min((MIN(N-1) + 2*p[1] + p[n]), (MIN(N-2) + 2*p[2] + p[n] + p[1]))
        p = sorted(p)
        r = [0]
        for i in range(1, n+1):
            if i <= 2:
                r.append(p[i-1])
                continue
            r.append(min((r[i-1] + 2*p[0] + p[i-1]),
                     (r[i-2] + 2*p[1] + p[0] + p[i-1])))
        return r[-1]


if __name__ == "__main__":
    p = [1, 2, 5, 10]
    n = len(p)
    s = Solution()
    print(s.over_bridge(p, n))
